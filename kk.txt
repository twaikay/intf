1. cache cluster: 
    - each node independent of other node crashes. Restart node to load from underlying persistence storage.
3. cache mode: partitioned: 1 primary, X backups: since data is huge and updates are frequent.
4. uS -> cache:
    a. if cache entry NOT exist, read through from persistent store.
    b. if cache not available OR needs to passthru, hit backend:
         - integration mechanism to backend?
    c. All inserts/updates services -> passthru to backend
4. Updates to cache:
    - Backend -> Kafka -> customSinkConnector -> update/insert cacheDB, cache.
    - NB: sync of data between cacheDB and cache can also be done using Oracle GoldenGrid (via GridGain).

Opt 1:
1. Persistence Storage: Ignite Native Persistence (NP):
    a. Data files (data+index) store in disk.
    b. No single point of failure: each node has its own data file system (independent of other data file crashes).
    c. cache starts up: FAST: lazy load from NP, data stored in memory same as in disk. Only load subset to cache.
    d. cache storage: small. Lazy loading from NP.
    e. cache expiration: handles by NP (LRU).
2. Data backup for recovery:
    - may use GridGrain Ultimate Edition to manage data file snapshots.
3. May not require cacheDB.

Opt 2:
1. Persistence Storage: RDBMS (MySQL, EDB, MariaDB):
    a. Data+Indexes store in cacheDB
    b. Single point of failure since still centralized cacheDB.
    c. cache start up: slow: load from cacheDB (DEV effort)
    d. cache storage: huge: SQL ops (e.g. joins) require all data to be pre-loaded into cache.
    e. cache expiration: handles by app (DEV effort)
2. Data backup for recovery:
    - in cacheDB.